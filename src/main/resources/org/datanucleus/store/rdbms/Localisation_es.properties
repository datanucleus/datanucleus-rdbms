################################################################################
# Copyright (c) 2003 Andy Jefferson and others. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Contributors:
#     ...
#
# Resources for org.datanucleus.store.rdbms package (Spanish)
################################################################################
#
# Schema mapping, columns etc
#
020000=La clase "{0}" no tiene una tabla en la base de datos, pero esta operacion la necesita. Por favor compruebe el MetaData
020001=El campo no tiene una columna en el base de datos : {0}
020002=El campo "{0}" es un "indexed List" pero tambien es una relacion M-N - no soportamos esta relacion como necesita un indice para cada lado de la relacion. Cambialo para usar Set o para ser un "ordered List".
020003=Las columnas "{0} " han sido definido con {1} columnas, pero hay solamente {2} en otro lado!
020004=Las columnas "{0}" tiene una columna "{1}" que ha sideo definido associar con "{2}" pero este no existe!
020005=Las columnas "{0}" numero de columna {1} no tiene otras columnas para asociar!
020006=Las columnas "{0}" tiene una columna "{1}" que ha sido asociado dos veces!
020007=El nombre de la columna "{0}", de la tabla "{1}" esta duplicado. No se pueden mapear varios campos a una misma columna. El columnas utilizada {2} y {3}. Vea tambien la propiedad "datanucleus.rdbms.allowColumnReuse"
020008=? datastore-identity|index columns|other non mapped to any field ?
020009=El tipo de dato de la columna "{0}" es incompatible : era {1} (datastore), pero debe ser {2} (metadata). Por favor compruebe que el tipo en la base de datos y el tipo en el MetaData son iguales.
020010=Las columnas requeridas no existen en la tabla {0} : {1}. Quizas el MetaData sea correcto, o no tiene "datanucleus.schema.autoCreateTables" como "true".
020011=La tabla no existe : {2} en Catalog {0} Schema {1}. El MetaData no es correcto, o necesita poner "datanucleus.schema.autoCreateTables" como "true"
020012=La tabla no es del tipo adecuado. Debe ser una tabla : {0} tipo {1}
020013=La tabla no es del tipo adecuado. Debe ser un view : {0} tipo {1}
020014=No se puede definir una columna de clave primaria en una vista : {0}, columna={1}
020015=Ha excedido el maximum de {0} claves foráneas por la tabla {1}
020016=Ha excedido el maximo de {0} índices por la tabla {1}
020017=La definition de vista para {0} : {1} no es válida
020018=La precision de la columna {0} no es correcta : era {1} (segun el driver de JDBC) pero debe ser {2} (segun la definicion de MetaData).
020019=La precision de la columna {0} no es correcta : era {1} (segun el driver de JDBC) pero debe ser {2} (segun la definicion de MetaData del {3}).
020020=La clave primaria de la tabla {0} {1} no existe en la lista de claves {2}
020021=La scala de la columna {0} no es correcta : era {1} (segun el driver de JDBC) pero debe ser {2} (segun la definicion de MetaData)
020022=La scala de la columna {0} no es correcta : era {1} (segun el driver de JDBC) pero debe ser {2} (segun la definicion de MetaData del {3})
020023=Las vistas no pueden tener una superclase persistence-capable : {0}
020024=La columna {0} encontrado en la tabla {1} schema {2} catalog {3} no debe ser alla 
020025=La columna {0} no debe permitir nulos pero los permite

020183=La columna {0} tiene una precision/escala, pero el tipo de la columna de la base de datos no permite nada.
020184=La precisión no es valido, columna = {0}

020185=El campo "{0}" debe utilisar estrategia de "subclass-table" pero no lo hace. Por favor abre un "bug"
020186=El campo "{0}" esta declarado para usar algunas claves ajenas y tiene una especificacion de las columnas, pero el numero de columnas ({1}) no es igual que el numero de claves ajenas de este campo ({2}).
020187=Una columna añadido por el tipo "{0}" del campo "{1}" (declarada para usar "subclass-table")
020188=Una columna añadido por la implementación "{0}" del campo "{1}" (declarada como referencia - "interface" o java.lang.Object)
020189=¡El campo "{0}" esta declarado como referencia ("interface" o java.lang.Object) ("{1}") y debe tener una implementación "{2}", pero esta clase no existe!
020190=¡El campo "{0}" esta declarado como referencia ("interface" o java.lang.Object) y debe tener una implementación "{1}" pero este es Interface también!

# This is type info so move to different range!
020191=Data type {0} no esta reconocido por JDBC. Va a ignorar la validación
020192=Usted ha puesto el {0} como {1} pero lo hemos cambiado a {2}. Es debido a la falta de caracteres de " o que la base de datos lo almacena en otro forma (mayusculos, menusculos?)

#
# Query ResultExpressions
#
021033=Query no puede crear objeto del tipo "{0}" como el constructor "{1}" no existe

021051=La expresión de "HAVING" "{0}" no es valido. Debe ser una expresión Boolean.

021062=Query tiene una referencia al campo/propiedad "{0}" de la clase "{1}" pero no existe!

021118=Query tiene el parametro "{0}" definido como "{1}" pero el valor es de tipo "{2}"!

021213=El resultado no puede tener un contenedor elegido

#
# RDBMS Views
#
031004=Validar la vista : {0}
031005=La clase "{0}" has been defined with an identity-type of "{1}". SQL Views cannot be used with this type. You must use "nondurable".
031006=Class "{0}" has been defined with field "{1}" with a persistence-modifier of "{2}". You cannot use this with SQL Views - must be persistent or transactional.
031007=Class "{0}" uses an SQL View, however the method "{1}" has just been called. This is not supported for SQL Views.
031008=Class "{0}" uses an SQL View consequently DataNucleus doesnt support the generation of new identities for objects of this type.
031009=Class "{0}" uses an SQL View, however you are not allowed to use macros (such as "{1}") in the view definition.

#
# Mapping
#
041000=El tipo de Java {0} no tiene una clase mapping por defecto en DataNucleus.
041001=El campo "{0}" con tipo de Java {1} no tiene una clase disponible para convertirlo en DataNucleus.

041004=De alguna manera {0}.{1}() estaba llamado, pero debiera ser imposible
041005=De alguna manera {0}.{1}() del mapping del campo "{2}" estaba llamado, pero debiera ser imposible
041006=El Constructor ({0},{1}) no existe por el tipo de Mapping {2}
041007=El Constructor ({0},{1},{2}) no existe por el tipo de Mapping {3}

041009=La generación del nuevo tipo de Mapping {0} ha fallada : {1}
041010=La generación del nuevo tipo de Mapping {0} por la tabla {1}, field {2} ha fallada : {3}
041011=Constructor {0}(ClassTable, int) no existe
041012=Puede usa {0} con un campo persistence-capable solamente
041013=El fichero plugin.xml tiene una clase de datastore-mapping de "{0}" pero no la existe
041014=El campo "{0}" tiene "mapping-class" de "{1}" pero esa clase no existe! Por favor, compruebela y empezar de nuevo.
041015=No es posible fijar el campo a un objeto de otro PersistenceManager
041016=Objeto no es PersistenceCapable. Objeto clase = {0}, valor = {1}

041018=El objeto "{0}" tiene campo "{1}" con relacion bidireccional 1-1 a "{2}" pero el campo "{3}" de ese objeto no tiene valor; DataNucleus va a ponerlo en el objeto directamente.
041019=El objeto "{0}" tiene campo "{1}" con valor de "{2}" pero vamos a borrar ese objeto asi que ponemos nulo en el campo.
041020=El objeto "{0}" tiene campo "{1}" con relacion bidireccional 1-1 a "{2}" pero el campo de ese objeto tiene relacion a "{3}"!

041022=El objeto "{0}" tiene campo "{1}" con relacion bidirectional N-1 a "{2}" pero la collección "{3}" no contiene este objeto.
041023=¡El campo "{0}" no tiene MetaData por un contenedor (collection/map/array) !

041034=Obtuvo objeto con OID "{0}"

041038=La columna de Primary Key "{0}" de la tabla "{1}" no esta designada

041042=El campo "{0}" esta "embedded". DataNucleus no soporte la persistencia de campos de Object como "embedded".

041044=El campo "{0}" es de referencia (interface/Object) de tipo "{1}" pero DataNucleus no puede asignar el campo al valor de tipo "{2}". Solo puede asignar el campo a un valor especificado por el atributo "implementation-classes".

041050=Un error ha sido tirado "{0}" para la posicion {1} de la columna "{2}" : {3}

#
045000=Tiempo de cumplir = {0} ms
045001=Tiempo de cumplir = {0} ms (numero de lineas cambiado = {1}) con el PreparedStatement "{2}"
045002=Tiempo de cumplir = {0} ms con el PreparedStatement "{1}"

#
# DataSource
#
047000=La clase del driver para su base de datos ("{0}") no se encuentra en el CLASSPATH. Por favor, compruebe que el CLASSPATH es correcto, y que también lo es el nombre de la clase del driver JDBC.
047001=Usted quiere usar una pool de conexiones de "{0}" pero no se encuentra una de las librerias ({1}).
047002=Ocurrió un error durante la creación de la pool de conexiones "{0}" para el driver JDBC "{1}" y la URL "{2}" : {3}
047003=El plugin de pool de conexiones de "{0}" no está en el CLASSPATH
047004=Ocurrió un error al intentar usar el plugin "{0}" por crear una pool de conexiones: {1}
047005=Ocurrío un error intentando de leer el archivo de configuración de una pool de conexiones : {0}
047006=La clase de driver JDBC no es válida "{0}" : quizás no haya puesto el JAR en el CLASSPATH, o el nombre de clase es incorrecto.
047007=No habia ningun driver de datasource especificado!
047008=Hemos creado {0} data source con pool tipo {1}
047009=No era posible creat {0} datasource para conecciones debido a falta de informacion o informacion incorrecta. Consulta al log, o los valores de las propiedades "datastore.connectionXXX"
047010=Cerrando pool de connecciones {0}

#
# Exceptions
#
048000 = Exception : {0}

#
# SchemaAutoStarter
#
049000=La recuperación de las clases del SchemaTable ha fallado : {0}
049001=La validación del SchemaTable por el esquema "{0}" ha fallado. No lo existe o no es posible validarlo : {1}
049002=Borrando la tabla {0} y creandola de nuevo
049003=La añadación de la clase {0} a la lista de clases manejadas ha fallado. : {1}
049004=Borrando la clase {0} de la lista de clases manejadas
049005=La borración de la clase {0} de la lista de clases manejadas ha fallado : {1}
049006=La borración de todas las clases manejadas ha fallado : {1}
049007=Los nombres de las clases y de las tablas estan almacenados en la tabla "{0}"
049010=Unknown error in datastore : {0}

#
# RDBMS Manager
#
050000=Era imposible poner el ConnectionProvider para ser "{0}" como ningun plugin existe con ese valor. Por favor compruebe el CLASSPATH y el valor
050001=Era imposible crear un ConnectionProvider con nombre "{0}" : "{1}"
050002=Default Catalog Name "{0}" esta especificado pero el adaptador de la base de datos (JDBC driver) no soporta la especificacion del nombre del catalogo
050003=Default Schema Name "{0}" esta especificado pero el adaptador de la base de datos (JDBC driver) no soporta la especificacion del nombre de la esquema
050004=La inicialización del base de datos ha fallado.
050005=Obtener una connección al base de datos da un error : {0}
050006=Por favor, compruebe que el nombre, el usuario y la contraseña de la base de datos son correctos.
050007=Could not obtain connection due to unknown reason. Check your database configuration.

050012=El SchemaData no es inicializado por el Catalogo "{0}", el Esquema "{1}"
050013=La clase {0} tiene una estrategia de heredar de "superclass-table", pero no hay una tabla de una superclase!
050014=La clase "{0}" tiene "embedded-only", asi que se puede persistir objetos solamente en las tablas de otras clases. No vamos a crear una tabla.
050015=La clase ({0}) tiene un nombre de tabla de {1}, pero esa tabla es de otra clase ({2}). DataNucleus va a usar otra definicion de la misma tabla y va a persistir objetos de las dos clases a la misma tabla en la base de datos. Es su responsibilidad asegurar que las dos clases son compatibles.
050016=Crear las tablas de Set es posible como efecto de añadir una clase nueva solamente
050017=La clase persistente con id "{0}" no esta
050018=¡Objeto con el id "{0}" no existe!
050019=Intenta de encontrar nueva identidad de application-identity para la clase ({0}) pero no usa "application identity".
050020=Intenta de encontrar nueva identidad de application-identity para la clase {0} pero el campo {1} no es de un tipo valido ({2}). Debe ser int/long/Integer/Long.
050021=La clase {0} esta definido usar el objectid-class {1}, pero este ya esta definido por otro arbol de herencia (e.g por la clase {2}). Usted debe corregirlo para que cada arbol de herencia usa su propio objectid-class.
050022=Id {0} is assigned to class {1}, but it's not the correct object-id type for this class.
050023=Obtener identidad proxima por la clase {0}
050024=Error durante el proceso obtener la conexión por la generación de valor : {0}
050025=Error durante el proceso cerrar la conexión por la generación de valor : {0}

050028=Cargando información de columna para las tablas "{0}" por el Catalogo "{1}", el Esquema "{2}"
050029=Información de columna cargado por el Catalogo "{0}", el Esquema "{1}", {2} tablas, tiempo = {3} ms
050030=No hay información de columna por la tabla "{0}"; la tabla no existe en la base de datos
050031=No hay información de columna por la columna "{0}" de la tabla "{0}"
050032=Información de columna cargado por la tabla "{0}" : hemos encontrado {1} columnas
050033=Información de columna cargado por la columna "{0}" de la tabla "{1}"
050034=No hay columna de identidad por la clase {0}
050035=Campo {0}.{1} no tiene una tabla propia para buscar {2}
050036=El nombre pseudo-campo {0} no existe en el macro {1}, debe ser "owner", "element" o "index"
050037=El nombre pseudo-campo {0} no existe en el macro {1}, debe ser "owner", "key" o "value"
050038=Añadir las clases al Catalog "{0}", al Esquema "{1}"
050039=Añadacion de las clases ha fallado como la transacción no es activo
050040=Hay un error en la creación de los elementos del esquema - restaurando
050041=Habia un error durante la auto creacion de los elementos del esquema. La excepcion siguiente ocurrio durante el proceso de restaurar lo de antes : {0}
050042=Clase o juncion referenciada {0} no es persistence-capable !
050043=Hemos encontrado unos errores durante la validación o creación de las tablas. Los errores estan en el log, y estan adjuntados a esta excepción.
050044=Una excepcion estaba tirada durante la addicion/validacion de algunas class(es) : {0}
050045=Borrando todas las clases de persistencia por el catalogo "{0}", esquema "{1}"
050046=Borrando la clase "{0}" de persistencia
050047=Una excepcion estaba tirada durante la borracion de algunas class(es) : {0}
050048=Cambiando la tabla "{0}" por el catalogo "{1}", esquema "{2}"
050049=No <join> metadata found for field {0} with non PersistenceCapable elements/values. This metadata {1} needs adding the join. 
050050=El campo "{0}" es una mapa que no tiene una tabla para juntar y ni la clase ni el valor tiene "mapped-by". ¡Es invalido!
050051=Argumento de Query {0} : debe ser un String con el filter, o otro Query para usar como el basis
050052=Exception tirado calculando la fecha del servidor de la base de datos : {0}

050053=Committing transaccion del esquema "{0}"
050054=Rolling back transaccion del esquema "{0}"
050055=Cerrando la conneccion de la transaccion del esquema "{0}"
050056=Excepcion tirado haciendo la operacion "{0}"
050057=Empezando transaccion del esquema con conneccion "{0}" y isolacion "{1}"

#
# RDBMS Adapter
#
051000=No hemos encontrado un adaptador por el Driver de JDBC. Usando "DatabaseAdapter" generico.
051001=No hemos encontrado la clase de adaptador de la base de datos "{0}". Por favor, compruebe que existe en el CLASSPATH.
051002=La clase del adaptador de base de datos "{0}" para el vendor "{1}" con prioridad "{2}" ha sido invalidado por la clase "{3}" con la misma prioridad
051003=El adaptador de Oracle no existe
051004=Utiliza el MetaData del base de datos da un error
051005=El tipo de JDBC "{0}" no esta soportado por el JDBC de este base de datos. Por favor compruebe el valor de "jdbc-type" y las capacidades de JDBC.
051006=Ningun de los tipos de JDBC estan soportados
051007=Tipo de SQL "{0}" (para le tipo de JDBC "{1}") estaba descartado por el adaptador del base de datos
051008=No soporta el nivel de isolación de transacciones {0}. No usado.
051009=Puede usa {0} con un campo persistence-capable
051010=El constructor {0}(ClassBaseTable,int) no existe
051011=Campos del tipo {0} no estan soportados
051012=No es posible usar el constructor del objeto mapping con la clase {0}
051013=No es posible crear un objeto mapping mapping con la clase {0}
051014=El Constructor de {0} ha fallado
051015=No sabe como determinar el nombre del catalogo por este tipo de RDBMS : {0} {1}
051016=No sabe como determinar el nombre del esquema por este tipo de RDBMS : {0} {1}
051017=El adaptador permite el catalogo en la definicion de las tablas
051018=El adaptador permite la esquema en la definicion de las tablas
051019=Este adaptador no soporta llaves auto-increment
051020=Este adaptador no soporta sequencias
051021=Este adaptador no soporta sequencias sin nombres
051022=Este adaptador no soporta sequencias con valor maximo.
051023=Este adaptador no soporta sequencias con tamaño de cache.
051024=Error : Este Driver de JDBC no tiene un nombre de producto. No era posible elegir un adaptador de RDBMS.
051025=Error : Este Driver de JDBC dio un error al punto de obtener el nombre de producto. No era posible elegir un adaptador de RDBMS : {0}
051026=Error : Un error ocurrio cuando creando un adaptador "{0}" para este Driver de JDBC : {1}
051027=Error initialising derby schema : {0}
051028=No soportamos una secuencia con nombre nulo

#
# SQLController
#
052100=Añadiendo el statement "{0}" al batch (tamaño del batch = {1})
052101=Hemos llegado al limite del batch y vamos a procesar SQL statement "{0}"
052102=No es posible de procesar el statement de batch "{0}", asi que no podemos poner "{1}" en batch. Procediendo como normal.
052103=El statement "{0}" ya es batchable
052104=Añadiendo statement "{0}" al batch para procesar (tamaño de batch = {1})
052106=La connección tiene statement de batch "{0}" pero no es posible procesarlo asi que procesando el query ("{1}") como normal y dejando el batch
052108=Ha tirado una excepción al hacer flush() a la base de datos
052109=Utilizando PreparedStatement "{0}" para la conneccion "{1}"
052110=Cerrando PreparedStatement "{0}"

#
# Request
#
052200=Intenta de poner un objeto de la clase "{0}" pero sin campos de identidad (de application identity).
052201=El objeto con id "{0}" en la tabla {1} no tiene una version en memoria pero usted quiere cambiarlo!! Por favor enviar un reportaje de bug a los desarroladores de DataNucleus
052202=El objeto con id "{0}" en la tabla {1} no tiene una version en memoria pero usted quiere borrarlo!! Por favor enviar un reportaje de bug a los desarroladores de DataNucleus
052203=Objeto "{0}" (id="{1}") ha sido cambiado en la base de datos después de la ultima leer. La transacción tiene version "{2}" pero ya no existe en la base de datos
052204=El objeto con id "{0}" en la tabla {1} ha sido borrado de la base de datos despues de la ultima leer.
052205=El objeto estaba puesto en la base de datos table {0} con una columna de "autoassign"/"identity", pero la base de datos dice que la identidad es nulo. Es un bug en la base de datos. Usted tiene que usar otra estrategia por este campo.
052206=El objeto "{0}" etaba puesto en la base de datos y ha recibido el valor de estrategia "{1}"
052207=Objeto "{0}" va a ser añadido a la tabla "{1}"
052208=Persistencia del objeto "{0}" con SQL "{1}" ha tirado un error : {2}
052209=Persistencia del objeto "{0}" va a llamar postInsert para el campo "{1}"
052210=Objeto "{0}" va a ser borrado de la tabla "{1}"
052211=Borra del objeto "{0}" con SQL "{1}" ha tirado un error : {2}
052212=Borra del objeto "{0}" va a llamar preDelete para el campo "{1}"
052213=Borra del objeto "{0}" va a procesar el campo "{1}"
052214=Objeto "{0}" va a tener los campos "{1}" cambiado en la tabla "{2}"
052215=Cambio del objeto "{0}" con SQL "{1}" ha tirado un error : {2}
052216=Cambio del objeto "{0}" va a llamar postUpdate para el campo "{1}"
052217=Cambio del objeto "{0}" va a cambiar el campo "{1}"
052218=Objeto "{0}" va a tener los campos "{1}" leido de la tabla "{2}"
052219=Lee del objeto "{0}" con SQL "{1}" ha tirado un error : {2}
052220=Buscar del objeto "{0}" con SQL "{1}" ha tirado un error : {2}
052221=Una pedida de obtener datos de una tabla con llave primaria con {0} columnas, pero el campo con que necesita juntar tiene {1} columnas! Por favor, informanos por el Forum de DataNucleus!
052222=Persistencia del objeto "{0}" va a llamar insertPostProcessing para el campo "{1}"
052223=Ubicacion de los objetos "{0}" va a hacer un SELECT en la tabla "{1}"

#
# ResultObjectFactory
#
052300=Query debe devolver un objeto de tipo "{0}" pero es abstracto! Vamos a usar la subclase "{1}". Usted debe considerar lo de poner un discriminator en la tabla
052301=Query debe devolver un objeto de tipo "{0}" pero es abstracto! Por favor compruebe los datos y el model

#
# FieldManager
#
052400=El campo {0} es nulo, pero es obligatorio como esta en el MetaData de JDO

#
# Query Statement
#
052500=El variable del surtido {0} ya esta en uso en pregunta : {1}
052501=El variable del surtido {0} no existe
052502=¡El Query necesitaba DISTINCT, pero no era posible poner "FOR UPDATE" porque la base de datos no permite un sintaxis asi!
052503=La clausa de "ORDER BY" necesita el mismo número de expresiones y direcciones, pero ha recibido {0} expresiones y {1} direcciones!
052504=La base de datos que usted usa no soporta el sintaxis necesario para esta operación "{0}"
052505=OracleAdapter solamente soporta las expresiones de boolean char
052506=¡El Query necesitaba GROUP BY, pero no era posible poner "FOR UPDATE" porque la base de datos no permite un sintaxis asi!
052507=¡El Query necesitaba HAVING, pero no era posible poner "FOR UPDATE" porque la base de datos no permite un sintaxis asi!
052508=¡El Query necesitaba ORDER BY, pero no era posible poner "FOR UPDATE" porque la base de datos no permite un sintaxis asi!
052509=¡El Query necesitaba mas que una tabla en el FROM, pero no era posible poner "FOR UPDATE" porque la base de datos no permite un sintaxis asi!

052510=Extensión de Query 'datanucleus.rdbms.query.resultSetType' tiene valores de scroll-sensitive,scroll-insensitive,forward-only solo.
052511=Extensión de Query 'datanucleus.rdbms.query.resultSetConcurrency' tiene valores de read-only,updateable solo.
052512=Extensión de Query 'datanucleus.rdbms.query.fetchDirection' tiene valores de forward,reverse,unknown solo.

052520=Generación del query va a seleccionar todos los campos de "{0}" como es nondurable identidad

#
# SQL Warnings
#
052700=SQL Warning : {0}
052701=Obtener las advertencias del Connection {0} da un error
052702=Obtener las advertencias del Statement {0} da un error
052703=Obtener las advertencias del ResultSet {0} da un error

#
# Extent
#
053000=No se puede crear el Extent porque la clase "{0}" no tiene campos persistentes
053001=No se puede crear el Extent porque la asociación del campo "{0}" no es apropiada de una columna de View, para la clase "{1}"
053002=No se puede crear el Extent para la clase "{0}" porque le hace falta la clase "{1}" y no existe en el CLASSPATH!

#
# Mappings
#
054000=No podemos manejar el tipo de SQL {1} por el tipo de Java {0} con este base de datos.
054001=No podemos manejar el tipo de SQL {1} por un campo "{2}" con el tipo de Java {0} con este base de datos.
054002=No podemos manejar el tipo de JDBC {1} por el tipo de Java {0} con este base de datos.
054003=No podemos manejar el tipo de JDBC {1} por un campo "{2}" con el tipo de Java {0} con este base de datos.
054004=No podemos manejar el tipo de Java {0} (jdbc-type="{1}, sql-type="{2}"). No soportamos este tipo.
054005=No podemos manejar el tipo de Java {0} (jdbc-type="{1}, sql-type="{2}") del campo "{3}". No soportamos este tipo.
054006=No podemos manejar el tipo de SQL {1} del campo {0} con este base de datos.
054007=No podemos manejar el tipo de JDBC {1} del campo {0} con este base de datos.
054008=No podemos manejar el tipo de Java {1} del campo {0} con este base de datos y con el tipo de JDBC/SQL puesto. Por favor, intentalo con otro tipo de JDBC/SQL, o dejalo vacio para DataNucleus usar el default.
054009=Soportando el tipo RDBMS de Java {0} (jdbc-type={1}, sql-type={2}, datastore-mapping-type={3}, default={4})
054010=No Soportando el tipo RDBMS de Java {0} (jdbc-type={1}, sql-type={2})
054011=No podemos manejar el tipo de SQL {1} por el tipo de Java {0} con este base de datos, intentando con el jdbc-type {2}.
054012=No podemos manejar el tipo de SQL {1} por un campo "{2}" con el tipo de Java {0} con este base de datos, intentando con el jdbc-type {3}.

055000=No hay un tipo de JDBC por la columna "{0}"
055001=No puede poner parametro de tipo {0} : valor = {1} en la columna "{2}" : {3}
055002=No puede obtener el resuelto de tipo {0} por el parametro = {1} en la columna "{2}" : {3}
055003=Nulo es invalido en la columna {0}
055004={0} es invalido en la columna {1}
055005=Objeto de tipo {0} no es Serializable
055006=Campo de boolean/Boolean almacenado en columna de tipo "{0}" tiene valor ilegal "{1}" al leerlo!
055007=Intento de poner el valor "{0}" en la columna "{1}" que tiene tamaño maximo de {2}. Por favor corrige el valor
055008=Intento de poner un 'char' sin valor pero este base de datos no soporta un valor asi. Usando ' '

#
# RDBMS Tables
#
057000=Ya existe la tabla : {0}
057001=La tabla no ha sido inicializada : {0}
057002=La tabla no ha sido validada : {0}
057003=Intenta de crear una tabla por la clase {0} que tiene una estrategia de heredar de "{1}". No debe tener su propia tabla.
057004=La clase {0} necesita una identidad
057005=El tipo de identidad de la clase {0} no es valido
057006=El persistence-modifier del campo {0} no es valido
057007=El campo "{0}" representa una mapa con la clave almacenada como un campo del valor, pero el campo ({1}) no existe en el valor.
057008=El campo "{0}" representa una mapa con el valor almacenado como un campo de la clave, pero el campo ({1}) no existe en la clave.
057009=El campo "{0}" representa una mapa sin tabla de juntar. Usted tiene que poner "mapped-by" para marcar que la clave esta almacenado con la clase del valor, o el valor esta almacenado con la clase de la clave.
057010=Campo [{0}] -> Columnas [{1}] usando mapping del tipo "{2}" ({3})
057011=No hay ningun campo asociado con la columna [{0}] que usa el tipo "{1}"
057012=Más que un mapa tiene su "mapped'by" puesto como el campo "{0}" (por ejemplo el campo "{1}"). Este puede causar problemas porque objetos de esta clase pueda ser parte de muchas relaciones y cosas como "dependent-field" posiblemente no va a funcionar correctamente debido a esta situación
057013=Tabla clase={0}, object-class={1}
057014=La clase "{0}" tiene una matriz con elemento "{1}" pero este elemento no tiene MetaData.
057015=No hay MetaData de <collection> por el campo {0}
057016=La clase "{0}" tiene una collección con elemento "{1}" pero este elemento no tiene MetaData.
057017=No hay MetaData de <map> por el campo {0}
057018=La clase "{0}" tiene un Map con valor "{1}" pero este valor no tiene MetaData.
057019=La clase "{0}" tiene un Map con clave "{1}" pero esta clave no tiene MetaData.
057020=La clase "{0}" tiene campo "{1}" con autoassign/identity, pero la base de datos no soporta esa facilidad.

057022=El campo "{0}" tiene un <order> que debe almacenar en la columna del campo de elemento "{1}". ¡Es invalido! Debe ser int/Integer.
057023=Table/View {0} ha sido inicializado
057024=La tabla {0} va a manejar la persistencia de los campos de la clase {1} (estrategia de heredar="{2}")
057025=No era posible determinar el nombre del esquema por este DataStore
057026=No era posible determinar el nombre del catalogo por este DataStore
057027=No era posible encontrar la tabla del Probe {0}
057028=Un error estaba tirado con {0} : {1}
057029=Crear la tabla {0}
057030=Borrar la tabla {0}
057031=Crear la columna {0} de la tabla {1}
057032=Validar la tabla : {0}
057034=La columna "{0}" añadió a la representación de la table.
057035=La columna de Primary Key "{0}" de la tabla "{1}" no esta designada
057036=No hemos encontrado el campo "{0}" de la clase "{1}" con una relación el campo "{2}"
057037=Los tipos de Application identity sequence (auto-increment) son long, Long, int o Integer, pero {0} esta especificado.
057038=Los tipos de Application identity sequence (auto-increment) son long, Long, int, Integer o String, pero {0} esta especificado.

057040=La tabla "{0}" debe tener un primary-key con la columna "{1}" pero esta columna no existe en la tabla. Por favor compruebe la especificación de <primary-key>.
057041=El tipo de clave dado por el campo de Map {0} usa una columna que ya estaba usado por el tipo de valor del campo de Map.
057042=El tipo de valor dado por el campo de Map {0} usa una columna que ya estaba usado por el tipo de clave del campo de Map.
057043=La columna "{0}" existe en la tabla "{1}" pero tiene metadata invalido. La columna es "{2}"
057044=La columna "{0}" existe en la tabla "{1}" y no podemos validarlo porque una columna duplicada ha sido especificado y su metadata es invalido. La columna es "{2}"
057045=No es posible crear una tabla secundaria ("{0}") sin la tabla primaria!


#
# Indices
#
058000=Crear el indice "{0}" en catalogo "{1}" equema "{2}"
058001=La tabla "{0}" tiene un indice "{1}" y una columna ("{2}") no esta.
058002=La tabla "{0}" tiene un indice "{1}" pero no tiene columnas.
058003=Los indices no existen en {0} : {1}
058004=Validando {0} indic(es) de la tabla {1}
058005=Validado {0} indic(es) de la tabla {1} con exito
058006=Un indice "{0}" tiene un campo "{1}" pero este campo no existe

#
# Foreign Keys
#
058100=Crear el constreñimiento del foreign key "{0}" en catalogo "{1}" equema "{2}"
058101=Los foreign keys no existen en {0} : {1}
058102=Borrando {0} foreign key(s) de la tabla {1}
058103=Validando {0} foreign key(s) de la tabla {1}
058104=Validado {0} foreign key(s) de la tabla {1} con exito
058105=El MetaData de "{0}" contiene un foreign-key al nivel de la clase pero no hay ningun "table". Todos los foreign keys para la clase deben tener "table" que es a donde va la clave.
058106=El MetaData de "{0}" contiene un foreign-key a la tabla "{1}" pero esa tabla es desconocida ahora mismo.
058107=El MetaData de "{0}" contiene un foreign-key a la tabla "{1}" usando la columna "{2}" pero la columna no existe en la tabla "{3}"
058108=El MetaData de "{0}" contiene un foreign-key a la tabla "{1}" pero implica {2} columnas a este lado y {3} columnas al otro lado. Deben ser igual.

#
# Candidate (Unique) Keys
#
058200=Crear la llave unica "{0}" en catalogo "{1}" equema "{2}"
058201=Las llaves unicas no existen en {0} : {1}
058202=La tabla "{0}" tiene una llave unica "{1}" y una columna ("{2}") no esta.
058203=La tabla "{0}" tiene una llave unica "{1}" pero no tiene columnas.
058204=Validando {0} llaves unicas de la tabla {1}
058205=Validado {0} llaves unicas de la tabla {1} con exito
058206=Una llave unica "{0}" tiene un campo "{1}" pero este campo no existe

#
# SQL
#
059003=El estatement de SQL ("{0}") no tiene ninguna columna en la selección. Es invalido.
059013=Query de SQL ("{0}") tiene una clase de candidato "{1}" pero no esta seleccionada la columna de identidad ("{2}"). Usted tiene que seleccionar la columna de identidad.
059014=Query de SQL tiene una clase de candidato "{0}" pero noa esta seleccionada la columna de discriminación "{1}". Usted tiene que seleccionar la columna de discriminación
059015=Query de SQL tiene una clase de candidato "{0}" pero no esta seleccionada la columna de versión "{1}". Usted tiene que seleccionar la columna de versión.
059017=La clase de candidato "{0}" esta incorecta para SQL. No puede tener un Extent (usa requires-extent="false" en el MetaData).
059018=La clase de candidato "{0}" esta incorecta para SQL. Tiene que usar identidad de non-durable (usa identity-type="nondurable" en el MetaData).
059019=El Query de SQL hace falta {0} parametros, pero hay {1} solamente.
059020=La clase de resultado {0} del Query de SQL no tiene campo {1}
059021=El Query de SQL tiene un macro invalido - clases resultadas no tienen tablas {0}
059022=El Query de SQL falta columnas ("{0}") del ResultSet
059023=El Query de SQL hace falta el parametro {0}, pero no esta.
059024=El Query de NucleusSQL hace falta el parametro {0}, pero no esta.
059027=Error con la extracción de resultados por el Query de SQL "{0}"
059029=SQL query "{0}" necesita un parametro para la posición {1} pero no hay ninguno en el Map.
059030=SQL query clase no tiene campos persistentes en el SELECT : {0}
059031=SQL query tiene parametro "{0}" pero no existe en el query : {1}

#
# SQL Expressions
#
060001=No se puede invocar el método "{0}" de la expresión "{1}"
060002=No se puede invocar la función "{0}" con la expresión "{1}"
060003=Invocación del método "{0}" de "{1}" necesita argumento {2} de tipo "{3}"
060004=No era posible crear un SQLExpression para el mapping del tipo "{0}" como no lo soportamos
060005=No era posible crear un SQLExpression para el mapping del tipo "{0}"!
060006=No era posible crear un SQLLiteral para el mapping del tipo "{0}" como no lo soportamos
060007=No hemos encontrado la clase de SQLLiteral "{0}"!
060008=No soportamos la invocacion del metodo "{0}" en la clase "{1}"
060009=No soportamos la invocacion de la funcion "{0}"
060010=No hemos encontrado la clase de SQLMethod "{0}"!
060011=La invocacion del SQLMethod "{0}" ha tirado una excepcion
060012=No soportamos la invocacion de la operacion "{0}"
060013=No hemos encontrado la clase de SQLOperation "{0}"!
060014=La invocación de la SQLOperation "{0}" ha tirado una excepcion
060015=La invocación del método "{0}" de "{1}" no acepta argumentos
060016=La invocación del método "{0}" de "{1}" hace falta {2} argumentos

#
# Value Generators
#
061000=No podíamos crear la sucesión "{0}"
061001=No podíamos obtener una nueva sucesión (unique id) : {0}
