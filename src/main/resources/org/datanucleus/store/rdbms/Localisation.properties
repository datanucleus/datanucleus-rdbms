################################################################################
# Copyright (c) 2003 Andy Jefferson and others. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Contributors:
#     ...
#
# Resources for org.datanucleus.store.rdbms package
################################################################################
#
# Schema Mapping, columns etc
#
020000=Persistent class "{0}" has no table in the database, but the operation requires it. Please check the specification of the MetaData for this class.
020001=Field has no corresponding database column : {0}
020002=Field "{0}" is an indexed List yet is also an M-N relation - this is not supported since it would need an index for both sides of the relation. Either make it the field a Set, or use an ordered List.
020003=Columns "{0} " have been defined with {1} columns, yet there are only {2} to map to!
020004=Table "{0}" has a column "{1}" which has been defined to map to column "{2}" in table "{3}" but this doesnt exist in mapping {4} (attempting to use a column other than the ID?)
020005=Columns "{0}" column number {1} has no remaining columns to map to!
020006=Columns "{0}" has a column "{1}" that has been mapped twice!
020007=Duplicate column name "{0}" defined for table "{1}". You cannot map multiple fields to the same column. The duplicated columns are specified by {2} and {3}. See also persistence property "datanucleus.rdbms.allowColumnReuse"
020008=? datastore-identity|index columns|other non mapped to any field ?
020009=Incompatible data type for column {0} : was {1} (datastore), but type expected was {2} (metadata). Please check that the type in the datastore and the type specified in the MetaData are consistent.
020010=Required columns missing from table "{0}" : {1}. Perhaps your MetaData is incorrect, or you haven't enabled "datanucleus.schema.autoCreateColumns".
020011=Required table missing : "{2}" in Catalog "{0}" Schema "{1}". DataNucleus requires this table to perform its persistence operations. Either your MetaData is incorrect, or you need to enable "datanucleus.schema.autoCreateTables"
020012=Table "{0}" is of wrong type {1}. Should be a table
020013=Table "{0}" is of wrong type {1}. Should be a view
020014=Cannot define a primary key column in a view : {0}, column={1}
020015=Exceeded maximum of {0} foreign keys for table {1}
020016=Exceeded maximum of {0} index keys for table {1}
020017=Invalid view definition for {0} : {1}
020018=Wrong precision for column {0} : was {1} (according to the JDBC driver) but should be {2} (based on the MetaData definition).
020019=Wrong precision for column {0} : was {1} (according to the JDBC driver) but should be {2} (based on the MetaData definition for field {3}).
020020=Expected primary key for table {0} {1} not found in existing keys {2}
020021=Wrong scale for column {0} : was {1} (according to the JDBC driver) but should be {2} (based on the MetaData definition).
020022=Wrong scale for column {0} : was {1} (according to the JDBC driver) but should be {2} (based on the MetaData definition for field {3}).
020023=Classes backed by views cannot have persistence-capable superclasses : {0}
020024=Unexpected column {0} encountered in table {1} schema {2} catalog {3}
020025=Column {0} should not allow nulls but does. You can prevent nulls by specifying "allows-null" as "false" for the <field> in the MetaData

020026=Adding/Dropping temporary table so we can determine the catalog/schema for this datasource. Specify "datanucleus.mapping.Catalog"/"datanucleus.mapping.Schema" to avoid this check

020183=Column {0} has been specified with precision/scale, yet the column datastore type doesn't allow specification of this
020184=Invalid precision, column = {0}


020185=Field "{0}" should be using "subclass-table" inheritance strategy yet isnt. Please report this.
020186=Field "{0}" is declared type requiring multiple FKs and has had its column(s) specified, however the number of columns specified ({1}) is not the same as the number of possible FKs for this field ({2}).
020187=Added column for type "{0}" for field "{1}" (field declared as using subclass-table)
020188=Added column for type "{0}" for field "{1}" (field declared as reference type - interface/Object)
020189=Field "{0}" is defined as a reference type (interface or Object) and was specified as being implemented by class "{1}" but this class was not found!
020190=Field "{0}" is defined as a reference type (interface or Object) ("{1}") and was specified as being implemented by class "{2}" but this is an interface!

# This is type info so move to different range!
020191=Data type {0} is not recognized by the JDBC. Validation will be ignored
020192=You have specified the default {0} as {1} but for this datastore this has been changed to {2}. This is likely due to missing quote characters, or the datastore storing things in a different case

#
# Query ResultExpressions
#
021033=Query cannot create object of type "{0}" since specified constructor "{1}" doesn't exist

021051="HAVING" expression "{0}" is not a valid boolean expression

021062=Query has reference to member "{0}" of class "{1}" yet this doesnt exist!

021118=Query has parameter "{0}" declared as "{1}" yet a value of type "{2}" was supplied

021213=Cannot select multi-valued objects in a result clause of a query

#
# Views
#
031004=Validating view : {0}
031006=Class "{0}" has been defined with field "{1}" with a persistence-modifier of "{2}". You cannot use this with SQL Views - must be persistent or transactional.
031007=Class "{0}" uses an SQL View, however the method "{1}" has just been called. This is not supported for SQL Views.
031008=Class "{0}" uses an SQL View consequently DataNucleus doesnt support the generation of new identities for objects of this type.
031009=Class "{0}" uses an SQL View, however you are not allowed to use macros (such as "{1}") in the view definition.

#
# Identifiers
#
039000=Case Identifier "{0}" is not supported. Please choose a supported case
039001=Identifier Factory required identifiers in "{0}" but datastore adapter doesnt support this exactly, so using "{1}" instead
039002=Identifier Factory requires identifiers in "{0}" but this is impossible with the current datastore adapter.
039003=Identifier Factory with name "{0}" is not registered! Please check your CLASSPATH for presence of the plugin containing this factory, and your PMF settings for identifier factory.
039004=Identifier Factory with name "{0}" was either not found, or the class it utilises was not found. Please check the plugin specification and the CLASSPATH
039005=Identifier Factory "{0}" has thrown an error upon construction. Please check the validity of the IdentifierFactory plugin.

#
# Mapping
#
041000=The Java type {0} has no default mapping class available in DataNucleus.
041001=The field "{0}" with Java type {1} has no known mapping class available in DataNucleus.

041004=Somehow {0}.{1}() was called, which should have been impossible!
041005=Somehow {0}.{1}() was called on the mapping for field="{2}", which should have been impossible!
041006=Constructor ({0},{1}) not found for Mapping type {2}
041007=Constructor ({0},{1},{2}) not found for Mapping type {3}
041008=Constructor ({0},{1},{2},{3}) not found for Mapping type {4}
041009=Failed to generate new Mapping of type {0}, exception : {1}
041010=Failed to generate new Mapping of type {0} for table {1}, field {2}, exception : {3}
041011=Missing constructor {0}(ClassTable, int)
041012={0} can only be used with a persistence-capable field
041013=The plugin.xml has specified a datastore-mapping class of "{0}" yet this is not found
041014=Field "{0}" has been specified to use a mapping class "{1}" yet this class was not found! Please check your metadata and respecify the mapping class.
041015=Cannot assign field to an object from a different PersistenceManager
041016=Object is not a PersistenceCapable instance. Object class = {0}, value = {1}

041017=Delete of "{0}" needs delete of related object at "{1}" but cannot delete it direct since FK is here. Will be deleted later by flush process
041018=Object "{0}" has field "{1}" with a 1-1 bidirectional relation set to relate to "{2}" but this object hasnt had the relation at field "{3}" set so updating the object directly.
041019=Object "{0}" has bidirectional field "{1}" currently set to "{2}" but this object is being deleted so nulling this field
041020=Object "{0}" has field "{1}" with a 1-1 bidirectional relation set to relate to "{2}" but this object relates back to a different object "{3}"!

041022=Object "{0}" has field "{1}" with an N-1 bidirectional relation set to relate to "{2}" but the collection at "{3}" doesn't contain this object.
041023=Specified field "{0}" has no container (collection/map/array) MetaData!

041034=Retrieved object with OID "{0}"

041036=Error creating application id of type {0} : exception is {1}
041037=Error creating application id of type {0}, field {1}, value {2} : exception is {3}
041038=Primary Key column "{0}" for table "{1}" is not mapped.
041039=Cannot create SingleFieldIdentity type since the key value retrieved from the datastore is NULL!

041042=Field "{0}" is specified as embedded. DataNucleus doesnt currently support the persistence of embedded Object fields.

041044=Field "{0}" is a reference field (interface/Object) of type {1} but DataNucleus is unable to assign an object of type "{2}" to this field. You can only assign this field to a type specified by the "implementation-classes" extension attribute.

041050=Failure in call to "{0}" for position {1} for column "{2}" : {3}

#
#
045000=SQL Execution Time = {0} ms
045001=SQL Execution Time = {0} ms (number of rows = {1}) on PreparedStatement "{2}"
045002=SQL Execution Time = {0} ms on PreparedStatement "{1}"

#
# DataSource
#
047000=The specified datastore driver ("{0}") was not found in the CLASSPATH. Please check your CLASSPATH specification, and the name of the driver.
047001=You have specified to use a "{0}" connection pool yet one of the required libraries for this ({1}) was not found.
047002=Error creating database connection pool of type "{0}" for driver "{1}" and URL "{2}" : {3}
047003=The connection pool plugin of type "{0}" was not found in the CLASSPATH!
047004=Attempt to invoke the "{0}" plugin to create a ConnectionPool gave an error : {1}
047005=Error reading the configuration file for the connection pool : {0}. Check that it is accessible in the CLASSPATH
047006=Invalid datastore driver class "{0}" : maybe you haven't specified the JDBC driver JAR in your CLASSPATH, or the name of the class is incorrect.
047007=No datastore driver class has been specified!
047008=Created ConnectionPool "{0}" as data source using pooling type of {1}
047009=Unable to create {0} datasource for connections due to invalid/insufficient input. Consult the log for details and/or review the settings of "datastore.connectionXXX" properties
047010=Closing ConnectionPool "{0}"

#
# Exceptions
#
048000= Exception : {0}

#
# SchemaAutoStarter
#
049000=Failed to retrieve classes from SchemaTable : {0}
049001=Failed to validate SchemaTable for Schema "{0}". Either it doesn't exist, or doesn't validate : {1}
049002=Dropping Schema Table "{0}" and recreating as new
049003=Error adding class {0} to list of persistence-managed classes : {1}
049004=Deleting class {0} from list of persistence-managed classes
049005=Error deleting class {0} from list of persistence-managed classes : {1}
049006=Error deleting all persistence-managed classes from supported list : {1}
049007=Class names and associated table names are stored in the datastore in a table "{0}"
049008=Unable to use the SchemaAutoStarter since it is not open!
049009=Unable to open the SchemaAutoStarter since it is already open!
049010=Unknown error in datastore : {0}

#
# RDBMS Manager
#
050000=Unable to set the ConnectionProvider to be "{0}" since no plugin exists for that value. Please check your setting and your CLASSPATH
050001=Unable to create a ConnectionProvider of name "{0}" : "{1}"
050002=Default Catalog name "{0}" has been specified yet the Database Adapter (JDBC driver) doesn't support specification of catalog name in table definitions !
050003=Default Schema name "{0}" has been specified yet the Database Adapter (JDBC driver) doesn't support specification of schema name in table definitions !
050004=Failed initialising database.
050005=Error obtaining connection to database : {0}
050006=Please check that your database JDBC driver is accessible, and the database URL and username/password are correct.
050007=Could not obtain connection due to unknown reason. Check your database configuration. e.g security/firewall problem?

050012=Schema Data has not been initialised for Catalog "{0}", Schema "{1}"
050013=Class "{0}" has been specified to use an inheritance strategy of "superclass-table", yet the table for a superclass cannot be found!
050014=Class "{0}" has been specified as "embedded-only", and so it can only exist within the tables of other classes. No table will be created.
050015=The class specified ({0}) has a default table name of {1}, but this is in use by a different class ({2}). DataNucleus will use a separate instance of this table internally and data will be persisted to the same datastore table. It is your responsibility to make sure that both of these classes are compatible for saving to the same place.
050016=Join Tables can only be created as a side effect of adding a new class
050017=Persistent Class not found for id "{0}"
050018=Object with id "{0}" not found for Class "{1}"!
050019=Attempt to find new application-identity for class ({0}) that does not use "application identity".
050020=Attempt to find new application-identity for class {0} yet field {1} has invalid type ({2}). Should be int/long/Integer/Long.
050021=Class {0} has been defined with objectid-class {1}, yet this is already used by a different inheritance tree (e.g by class {2}). Please correct this so that each inheritance tree uses their own objectid-class.
050022=Id {0} is assigned to class {1}, but it's not the correct object-id type for this class.
050023=Obtaining next ID for class {0}
050024=Error while obtaining connection for value generation : {0}
050025=Error while closing connection for value generation : {0}

050028=Loading column info for table(s) "{0}" in Catalog "{1}", Schema "{2}"
050029=Column info loaded for Catalog "{0}", Schema "{1}", {2} tables, time = {3} ms
050030=No column info found for table "{0}" - the table apparently doesnt yet exist in the datastore
050031=No column info found for column "{0}" of table "{1}"
050032=Column info retrieved for table "{0}" : {1} columns found
050033=Column info retrieved for column "{0}" of table "{1}"
050034=Table for class {0} has no ID column
050035=Field {0}.{1} has no table of its own in which to look for {2}
050036=Invalid pseudo-field name {0} in macro {1}, must be "owner", "element" or "index"
050037=Invalid pseudo-field name {0} in macro {1}, must be "owner", "key" or "value"
050038=Add classes to Catalog "{0}", Schema "{1}"
050039=Add classes transaction is not active
050040=An error occurred while auto-creating schema elements - rolling back
050041=An error occurred while auto-creating schema elements. The following exception occurred while attempting to rollback the partially-completed schema changes : {0}
050042=Referenced class/interface {0} is not persistence-capable !
050043=Error(s) were found while auto-creating/validating the datastore for classes. The errors are printed in the log, and are attached to this exception.
050044=An exception was thrown while adding/validating class(es) : {0}
050045=Removing all classes from persistence management for Catalog "{0}", Schema "{1}"
050046=Removing class "{0}" from persistence management
050047=An exception was thrown while dropping class(es) : {0}
050048=Updating table "{0}" for Catalog "{1}", Schema "{2}"
050049=No <join> metadata found for field {0} with non PersistenceCapable elements/values. This metadata {1} needs adding the join. 
050050=Field "{0}" is a map that has been specified without a join table and neither the key nor the value has a mapped-by specified. This is invalid!
050051=Invalid query argument {0} : should be a String containing a filter for the query, or an existing Query to use as a basis.
050052=Exception thrown trying to get the server date : {0}

050053=Schema Transaction COMMITTING with connection "{0}"
050054=Schema Transaction ROLLING BACK with connection "{0}"
050055=Schema Transaction CLOSED with connection "{0}"
050056=Schema Transaction threw exception "{0}"
050057=Schema Transaction STARTED with connection "{0}" with isolation "{1}"

#
# RDBMS Adapter
#
051000=No Database Adapter was found for your JDBC driver specified. Faling back to the generic DatabaseAdapter!
051001=The Datastore Adapter class "{0}" was not found. If this is a class that was specified by you in initialising the PMF, please try the DataNucleus auto-detection instead since your class wasnt found.
051002=The Datastore Adapter class "{0}" for vendor-id "{1}" with priority "{2}" was overridden by class "{3}" with the same priority
051003=The Oracle adapter was not found
051004=Error accessing database MetaData
051005=JDBC type "{0}" not supported by the JDBC driver. Please check your specification of "jdbc-type" and the driver capabilities.
051006=None of the specified JDBC types are supported
051007=SQL type "{0}" (for JDBC type "{1}") was discarded by the database adapter
051008=Transaction Isolation level {0} is unsupported. Not used.
051009={0} can only be used with a persistence-capable field
051010=Missing constructor {0}(ClassBaseTable,int)
051011=Fields of type {0} not (yet) supported
051012=Can't access constructor for mapping object with class {0}
051013=Can't instantiate mapping object with class {0}
051014=Constructor for {0} failed
051015=Don't know how to determine the current catalog name for this type of DBMS : {0} {1}
051016=Don't know how to determine the current schema name for this type of DBMS : {0} {1}
051017=Database adapter allows catalogs to be used in table definitions
051018=Database adapter allows schemas to be used in table definitions
051019=This adapter does not support auto-increment keys
051020=This adapter does not support sequences
051021=This adapter does not support sequences without names
051022=This adapter does not support sequences with max value.
051023=This adapter does not support sequences with cache sizes.
051024=Error : This JDBC driver has no product name. Unable to select the requisite RDBMS adapter.
051025=Error : This JDBC driver gave an error when trying to access the product name. Unable to select the requisite RDBMS adapter : {0}
051026=Error : An error occurred trying to instantiate an instance of the adapter "{0}" for this JDBC driver : {1}
051027=Error initialising derby schema : {0}
051028=Sequences with null name are not supported

#
# SQLController
#
052100=Adding statement "{0}" to the current batch (new batch size = {1})
052101=The current batch limit has been reached so processing batched SQL statement "{0}"
052102=The currently being batched SQL statement "{0}" is not yet processable, so unable to batch the requested statement "{1}". Processing as normal
052103=The requested statement "{0}" has been made batchable
052104=Batch has been added to statement "{0}" for processing (batch size = {1})
052106=Connection has a batched statement "{0}" but is not yet processable so leaving it and processing query statement ("{1}")
052108=Exception thrown flushing changes to datastore
052109=Using PreparedStatement "{0}" for connection "{1}"
052110=Closing PreparedStatement "{0}"

#
# Extent
#
053000=Extent cannot be created because the class "{0}" has no persistent fields.
053001=Extent cannot be created because the field mapping "{0}" is unsuitable for a view column, for class "{1}"
053002=Extent cannot be created for "{0}" since it requires the loading of subclass "{1}" and this was not found in the CLASSPATH!.

#
# Request
#
052200=Insert attempted for class "{0}" yet no (application identity) field(s) was provided.
052201=Object with id "{0}" in table {1} has no version set on the object in memory and you want to update it!! Please report this bug to the developers of DataNucleus with a way of reproducing it
052202=Object with id "{0}" in table {1} has no version set on the object in memory and you want to delete it!! Please report this bug to the developers of DataNucleus with a way of reproducing it
052203=Object "{0}" (id="{1}") has been changed in the datastore since your last read. Your transaction is using version "{2}" but this doesnt exist in the datastore now
052204=Object with id "{0}" in table {1} has been deleted from the datastore since your last read.
052205=Object was inserted into the datastore table {0} with an "autoassign"/"identity" column, yet the datastore returns null when asked for the value of the identity. This is a bug in your datastore driver. The workaround is to use an alternative datastore/value strategy for the field.
052206=Object "{0}" was inserted in the datastore and was given strategy value of "{1}"
052207=Object "{0}" being inserted into table "{1}"
052208=Insert of object "{0}" using statement "{1}" failed : {2}
052209=Insert of object "{0}" is calling postInsert for field "{1}"
052210=Object "{0}" being deleted from table "{1}"
052211=Delete of object "{0}" using statement "{1}" failed : {2}
052212=Delete of object "{0}" is calling preDelete for field "{1}"
052213=Delete of object "{0}" is processing field "{1}"
052214=Object "{0}" having fields "{1}" updated in table "{2}"
052215=Update of object "{0}" using statement "{1}" failed : {2}
052216=Update of object "{0}" is calling postUpdate for field "{1}"
052217=Update of object "{0}" is updating field "{1}"
052218=Object "{0}" having fields "{1}" fetched from table "{2}"
052219=Fetch of object "{0}" using statement "{1}" failed : {2}
052220=Search for object "{0}" using statement "{1}" failed : {2}
052221=A fetch request has a main table with primary key with {0} columns, yet the passed field which will join to it has {1} columns! Please report this as a DataNucleus bug!
052222=Insert of object "{0}" is calling insertPostProcessing for field "{1}"
052223=Locate of objects "{0}", performing SELECT on table "{1}"

#
# ResultObjectFactory
#
052300=Query should return an instance of type "{0}" yet this is abstract! Falling back to its next subclass of "{1}". Consider using a discriminator in the table to define the type
052301=Query should return an instance of type "{0}" yet this is abstract! Please check your data and model

#
# FieldManager
#
052400=Field {0} is null, but is mandatory as it's described in the jdo metadata

#
# Query Statement
#
052500=Range variable {0} already in use in query : {1}
052501=Range variable {0} doesn't exist
052502=The query required use of DISTINCT, however it was not possible to use the "FOR UPDATE" lock because the RDBMS doesnt support the use of this syntax in one query
052503=The ordering clause should be passed the same number of ordering expressions and ordering directions but was passed {0} expressions and {1} directions!
052504=The datastore in use doesnt support the necessary syntax required for this operation "{0}".
052505=OracleAdapter only supports boolean char expressions
052506=The query required use of GROUP BY, however it was not possible to use the "FOR UPDATE" lock because the RDBMS doesnt support the use of this syntax in one query
052507=The query required use of HAVING, however it was not possible to use the "FOR UPDATE" lock because the RDBMS doesnt support the use of this syntax in one query
052508=The query required use of ORDER BY, however it was not possible to use the "FOR UPDATE" lock because the RDBMS doesnt support the use of this syntax in one query
052509=The query required use of multiple FROM tables, however it was not possible to use the "FOR UPDATE" lock because the RDBMS doesnt support the use of this syntax in one query

052510=Query extension 'datanucleus.rdbms.query.resultSetType' has valid values of scroll-sensitive,scroll-insensitive,forward-only only.
052511=Query extension 'datanucleus.rdbms.query.resultSetConcurrency' has valid values of read-only,updateable only.
052512=Query extension 'datanucleus.rdbms.query.fetchDirection' has valid values of forward,reverse,unknown only

052520=Query generation selecting all fields of "{0}" since nondurable identity

#
# SQL Warnings
#
052700=SQL Warning : {0}
052701=Error obtaining warnings from connection {0}
052702=Error obtaining warnings from statement {0}
052703=Error obtaining warnings from result-set {0}

#
# Mappings
#
054000=SQL type {1} declared for field of java type {0} cant be mapped for this datastore.
054001=SQL type {1} declared for field "{2}" of java type {0} cant be mapped for this datastore.
054002=JDBC type {1} declared for field of java type {0} cant be mapped for this datastore.
054003=JDBC type {1} declared for field "{2}" of java type {0} cant be mapped for this datastore.
054004=The java type {0} (jdbc-type="{1}", sql-type="{2}") can't be mapped for this datastore. No mapping is available.
054005=The java type {0} (jdbc-type="{1}", sql-type="{2}") for field "{3}" can't be mapped for this datastore. No mapping is available.
054006=SQL type {1} declared for field {0} cant be mapped for this datastore.
054007=JDBC type {1} declared for field {0} cant be mapped for this datastore.
054008=The java type {1} declared for field {0} can't be mapped for this datastore using the JDBC/SQL type specified. Please either change the JDBC/SQL type specification, or remove it so that the DataNucleus default can be tried.
054009=RDBMS support configured for "{0}" using jdbc-types=[{1}], sql-types=[{2}] with default (jdbc-type={3}, sql-type={4})
054010=Removing RDBMS support for Java type {0}, jdbc-type={1}
054011=SQL type {1} declared for field of java type {0} unknown internally for this datastore, so trying jdbc-type {2}. Mapping is likely non-optimal without specific sql-type support
054012=SQL type {1} declared for field "{2}" of java type {0} unknown internally for this datastore, so trying jdbc-type {3}. Mapping is likely non-optimal without specific sql-type support

055000=No suitable JDBC type found for column "{0}"
055001=Cannot set {0} parameter: value = {1} for column "{2}" : {3}
055002=Cannot get {0} result for param = {1} for column "{2}" : {3}
055003=Illegal null value in column {0}
055004=Illegal value {0} in column {1}
055005=Object of type {0} isn't Serializable
055006=Boolean field stored in "{0}" column had illegal value "{1}" when retrieved from the datastore!
055007=Attempt to store value "{0}" in column "{1}" that has maximum length of {2}. Please correct your data!
055008=Attempt to store a char with unassigned value (0x0) but this database doesnt support storing this value. Using space (' ') instead
055009=Object "{0}" has field "{1}" with a 1-N bidirectional relation and adding element "{2}" so setting the owner of the element.
055010=Object "{0}" has a 1-N bidirectional collection field "{1}" and having element removed. Element "{2}" is having its owner field nulled.

#
# SCO
#
056000=The field "{0}" has been declared as being an array, yet there is no <array> MetaData specified!
056001=The field "{0}" has been declared as being a collection, yet there is no <collection> MetaData specified!
056002=The field "{0}" has been declared as being a map, yet there is no <map> MetaData specified!
056003=The MetaData for the element class "{0}" of the collection field "{1}" was not found.

056006=Iteration request failed : {0}
056007=Size request failed : {0}
056008=Contains request failed : {0}
056009=Add request failed : {0}
056010=Update embedded key failed : {0}
056011=Update embedded value failed : {0}
056012=Remove request failed : {0}
056013=Clear request failed : {0}
056014=Get request failed : {0}
056015=Set request failed : {0}
056016=Put request failed : {0}
056017=IndexOf request failed : {0}

056019=ContainsValue request failed : {0}
056020=MaxAdapterColumnId request failed : {0}

056024=Field "{0}" has been defined as "mapped-by" the field "{1}" yet this "mapped-by" field doesnt exist in the class "{2}".
056025=Field "{0}" has been defined as "mapped-by" field "{1}" yet this is of an incorrect type ({2}). The field that is set as the "mapped-by" must be of type "{3}"
056026=The owner field {0} of element class {1} has an incorrect type "{2}". Should be "{3}"
056027=Could not update the foreign key using statement : {0}

#
# SCO Collection 
#
056028=Collection field "{0}" has been specified to contain the element "{1}" unembedded yet this is already identified as being stored embedded in a different field. This is invalid. You can't store the same object embedded and unembedded!
056029=Class "{0}" has collection field "{1}" and this has no mapping in the table for the element class "{2}" owner field "{3}"
056030=Class "{0}" has collection field "{1}" and this has no mapping in the table for the element class "{2}"
056031=The field "{0}" is a collection field where the elements use "subclass-table" inheritance strategy and where there are more than 1 subclass where the element is persisted. DataNucleus doesnt currently support this situation.

056033=Class {0} is not a valid element type for this collection (Field "{1}"). Must be "{2}" or subclass
056034=Removal of element(s) from FK Collection deletes the element(s) since the field is "dependent"
056035=Removal of element(s) from FK Collection deletes the element(s) since owner/index columns weren't nullable
056036=Removal of element(s) from FK Collection nulls the FK while leaving the element(s) intact.
056037=Object "{0}" has a collection "{1}" yet element "{2}" doesnt have the owner set. Managing the relation and setting the owner.
056038=Object "{0}" has a collection "{1}" yet element "{2}" has its owner set to "{3}". This is inconsistent and needs correcting.

#
# SCO Set
#
056039=Null elements not allowed in persistent sets.
056040=Collection field "{0}" of "{1}" was asked to add element "{2}" to the M-N bidirectional relation but the element already has this field in its collection (maybe added from the other side)

#
# SCO List
#
056041=Class "{0}" has collection field "{1}" and this has no mapping in the table for the index of the element class "{2}". Maybe you declared the field as a java.util.Collection and instantiated it as a java.util.List yet omitted the <order> element in the MetaData ?
056042=Remove of element from Inverse List deleted the element since owner/index columns weren't nullable
056043=Remove of element from Inverse List removed the element from the List while leaving the element intact.
056044=Field "{0}" has been instantiated as a List using a join table yet the join table has no "ordering" column. Please specify the <order> tag in the MetaData.

#
# SCO Array
#
056045=The field "{0}" is an array field where the elements use "subclass-table" inheritance strategy and where there are more than 1 subclass where the element is persisted. DataNucleus doesnt currently support this situation.
056046=Class "{0}" has array field "{1}" and this has no mapping in the table for the element class "{2}" owner field "{3}"
056047=Class "{0}" has array field "{1}" and this has no mapping in the table for the element class "{2}"
056048=Class "{0}" has array field "{1}" and this has no mapping in the table for the index of the element class "{2}"

#
# SCO Map
#
056050=The Map "{0}" has been specified without a key "mapped-by" field. You must specify a <key mapped-by=...> since the key is a field in the value class.
056051=The Map "{0}" has been specified with a key type of "{1}" yet the field of the key in the value class is of type "{2}"!
056052=Value class "{0}" has been defined to contain a field "{1}" that represents the key of the map but this field was not found!
056053=Class "{0}" has map field "{1}" and this has no mapping in the table for the value class "{2}" key field "{3}"
056054=Class "{0}" has map field "{1}" and this has no mapping in the table for the key class "{2}" value field "{3}"
056055=The owner field {0} of value class {1} has an incorrect type "{2}". Should be "{3}"
056056=Class "{0}" has map field "{1}" and this has no mapping in the table for the value class "{2}"
056057=The Map "{0}" has been specified without a value "mapped-by" field. You must specify a <value mapped-by=...> since the value is a field in the key class.
056058=The Map "{0}" has been specified with a value type of "{1}" yet the field of the value in the key class is of type "{2}"!
056059=Key class "{0}" has been defined to contain a field "{1}" that represents the value of the map but this field was not found!
056060=Can't write key from a different Persistence Manager
056061=Can't write value from a different Persistence Manager
056062=Null keys not allowed in persistent maps.
056063=Null values not allowed in persistent maps.
056064=Class {0} is not a valid key type for this Map. Must be {1}
056065=Class {0} is not a valid value type for this Map. Must be {1}
056066=Map at "{0}" has been specified with a value-type "{1}" which is an interface. DataNucleus doesnt currently fully support the use of value-types that are interfaces. Please change the value-type to be a class.
056067=Field "{0}" has been defined as "mapped-by" the field "{1}" yet this "mapped-by" field doesn't exist in the class "{2}".
056068=Field "{0}" has been defined as "mapped-by" field "{1}" yet this is of an incorrect type ({2}). The field that is set as the "mapped-by" must be of type "{3}"
056069=The MetaData for the key class "{0}" of the map field "{1}" was not found.
056070=The MetaData for the value class "{0}" of the map field "{1}" was not found.
056071=Field "{0}" is a Map formed by a ForeignKey. There is no key/value "mapped-by" specified. You must specify <key mapped-by="..."> if you want to use a Map ForeignKey relation.
056072=Field "{0}" is a Map formed by a ForeignKey where the key is stored in the value object, however the value object is not persistable (it is "{1}"). The value must be persistable to use this type of relation.
056073=Field "{0}" is a Map formed by a ForeignKey where the value is stored in the key object, however the key object is not persistable (it is "{1}"). The key must be persistable to use this type of relation.
056074=Field "{0}" is a Map formed by a ForeignKey where the value is stored in the key object, however the DataNucleus doesnt currently support this type of relation.
056075=The field "{0}" is a collection field defined with an element type of "{1}" There are no concrete types persistable here
056076=Class "{0}" has not got its own table and no subclass tables are found for this class. Creation of schema is impossible!

#
# Tables
#
057000=Table object has already been initialised : {0}
057001=Table object has not been been initialised : {0}
057002=Table has not been validated : {0}
057003=Attempt to create table for class {0} which has been specified to use an inheritance strategy of "{1}". This means it should not have its own table.
057004=No identity not supported for class {0}
057005=Invalid identity type for class {0}
057006=Invalid persistence-modifier for field {0}
057007=The field "{0}" represents a map with the key stored as a field in the value, yet the field specified ({1}) isnt found in the value class.
057008=The field "{0}" represents a map with the value stored as a field in the key, yet the field specified ({1}) isnt found in the key class.
057009=The field "{0}" represents a map with no join table. In this case you must specify "mapped-by" on either the key or the value element to specify that either the key is stored in the value class, or that the value is stored in the key class.
057010=Field [{0}] -> Column(s) [{1}] using mapping of type "{2}" ({3})
057011=There is no field associated with the column [{0}] using the type "{1}"
057012=More than one map has its "mapped-by" attribute set to field "{0}" (for example field "{1}"). This could cause a problem since objects of this class can, as a result, be part of multiple relationships and so functionality like dependent-field may not work reliably.
057013=Table class={0}, object-class={1}
057014=Class "{0}" has been defined with an array of element "{1}" yet no MetaData is found for this element.
057015=No <collection> MetaData found for field {0}
057016=Class "{0}" has been defined with a Collection containing element "{1}" yet no MetaData is found for this element.
057017=No <map> MetaData found for field {0}
057018=Class "{0}" has been defined with a Map containing value "{1}" yet no MetaData is found for this value.
057019=Class "{0}" has been defined with a Map containing key "{1}" yet no MetaData is found for this key.
057020=Class "{0}" has field "{1}" specified as using autoassign/identity, yet the RDBMS in use doesn't support this feature

057022=Field "{0}" has an <order> defined to be persisted into the column of field "{1}". This field is of an invalid type. Must be an int/Integer.
057023=Table/View {0} has been initialised
057024=Table {0} will manage the persistence of the fields for class {1} (inheritance strategy="{2}") 
057025=Schema Name could not be determined for this datastore
057026=Catalog Name could not be determined for this datastore
057027=Probe table {0} could not be found
057028=Error thrown executing {0} : {1}

057032=Validating table : {0}
057033=Class "{0}" uses an SQL Table, however you are not allowed to use macros (such as "{1}") in the table definition.
057035=Primary Key column "{0}" for table "{1}" is not mapped.
057036=Unable to find the field "{0}" in the class "{1}" with a relationship to the field "{2}"
057037=Application identity sequence (auto-increment) types can only be long, Long, int or Integer, yet {0} specified.
057038=Application identity sequence (auto-increment) types can only be long, Long, int, Integer, and String yet {0} specified.

057040=Table "{0}" has been specified with a primary-key to include column "{1}" but this column is not found in the table. Please check your <primary-key> column specification.
057041=The Key Type provided for the Map field {0} uses a column that was already used by the Type Value of the Map field.
057042=The Value Type provided for the Map field {0} uses a column that was already used by the Type Key of the Map field.
057043=The column "{0}" exists in table "{1}" yet requested to add one with the same identifier! Specify the column names in your schema to avoid duplication
057044=The column "{0}" exists in table "{1}" and cannot be validated because a duplicated column has been specified and the metadata is invalid. The column is "{2}"
057045=It is not possible to create a SecondaryTable ({0}) without the primary table that it relates to.


#
# Indices
#
058001=Table "{0}" has been specified with an index "{1}" and one of the columns defined ("{2}") is not found.
058002=Table "{0}" has been specified with an index "{1}" but has no columns defined
058003=Required indexes missing from {0} : {1}
058004=Validating {0} index(es) for table {1}
058005=Validated {0} index(es) for table {1} successfully
058006=An index "{0}" has been specified to include field "{1}" but this field was not found.

#
# Foreign Keys
#
058101=Required foreign keys missing from {0} : {1}
058102=Dropping {0} foreign key(s) for table {1}
058103=Validating {0} foreign key(s) for table {1}
058104=Validated {0} foreign key(s) for table {1} successfully
058105=The MetaData for "{0}" is specified with a foreign-key at class level yet no "table" is defined. All foreign-keys at this level must have a table that the FK goes to.
058106=The MetaData for "{0}" is specified with a foreign-key to table "{1}" yet this table is not currently known.
058107=The MetaData for "{0}" is specified with a foreign-key to table "{1}" using column "{2}" yet this column is not present in table "{3}"
058108=The MetaData for "{0}" is specified with a foreign-key to table "{1}" yet this implies {2} columns at this side and {3} columns at the other side. They should be equal.

#
# Candidate (Unique) Keys
#
058201=Required candidate keys missing from {0} : {1}
058202=Table "{0}" has been specified with a unique key "{1}" and one of the columns defined ("{2}") is not found.
058203=Table "{0}" has been specified with a unique key "{1}" but has no columns defined
058204=Validating {0} unique key(s) for table {1}
058205=Validated {0} unique key(s) for table {1} successfully
058206=A unique key "{0}" has been specified to include field "{1}" but this field was not found.

#
# SQL
#
059000=Deletion by query is not supported for SQL queries.
059001=You have specified an empty SQL query. This is invalid.
059002=You have specified an SQL statement ("{0}") that doesnt start with SELECT. This is invalid.
059003=You have specified an SQL statement ("{0}") that has no columns selected. This is invalid.
059004=Candidate extents not applicable to SQL queries.
059005=Candidate collections not applicable to SQL queries.
059006=Result is not applicable to SQL queries.
059007=Range is not applicable to SQL queries.
059008=Filter strings not applicable to SQL queries.
059009=Variables not applicable to SQL queries.
059010=SQL only supports grouping when set explicitly using a GROUP BY in the SQL text.
059011=SQL only supports ordering when set explicitly using an ORDER BY in the SQL text.
059012=SQL Query : "{0}"
059013=SQL query ("{0}") has been specified with a candidate class "{1}" yet the id column ("{2}") has not been selected. When you specify a candidate class you MUST select the id column(s).
059014=SQL query ("{0}") has been specified with a candidate class "{1}" yet the discriminator column "{2}" has not been selected. When you specify a candidate class you MUST select the discriminator column.
059015=SQL query ("{0}") has been specified with a candidate class "{1}" yet the version column "{2}" has not been selected. When you specify a candidate class you MUST select the version column.
059016=Parameters are untyped in SQL queries.
059017=Invalid candidate class "{0}" for SQL. It must not have an extent (use requires-extent="false" in the MetaData).
059018=Invalid candidate class "{0}" for SQL. It must use non-durable identity (use identity-type="nondurable" in the MetaData).
059019=The SQL query requires {0} parameters, yet only {1} have been provided.
059020=SQL query result class {0} has no such field {1}
059021=SQL query has invalid macro - result classes have no table {0}
059022=SQL query has columns missing ("{0}") from the result set
059023=SQL query requires the parameter {0}, yet it hasn't been provided.
059024=SQL query has an undeclared parameter {0} in the SQL
059025=Error executing SQL query "{0}".
059026=Imports not applicable to SQL queries.
059027=Error encountered when extracting results for SQL query "{0}"
059028=SQL query "{0}" requires {1} parameters yet none have been supplied
059029=SQL query "{0}" requires a parameter at position {1} yet none was supplied as input
059030=SQL query class has no persistent fields in the SELECT : {0}
059031=SQL query has parameter "{0}" yet not found in the query : {1}

#
# SQL Expressions
#
060001=Cannot invoke method "{0}" on expression "{1}"
060002=Cannot invoke function "{0}" with expression as "{1}"
060003=Invocation of method "{0}" on "{1}" requires argument {2} of type "{3}"
060004=Unable to create SQLExpression for mapping of type "{0}" since not supported
060005=Creation of SQLExpression for mapping "{0}" caused error
060006=Unable to create SQLLiteral for mapping of type "{0}" since not supported
060007=Expected SQLLiteral class "{0}" was not found!
060008=Invocation of method "{0}" on "{1}" is not supported
060009=Invocation of function "{0}" is not supported
060010=Expected SQLMethod class "{0}" was not found!
060011=Invocation of SQLMethod "{0}" threw exception
060012=Invocation of operation "{0}" is not supported
060013=Expected SQLOperation class "{0}" was not found!
060014=Invocation of SQLOperation "{0}" threw exception
060015=Invocation of method "{0}" on "{1}" does not accept arguments
060016=Invocation of method "{0}" on "{1}" requires {2} arguments
060017=Could not create TypeConverterExpression for mapping of type {0} with datastoreType={1} - no available supported expression
060018=Request to invoke "{0}" on type={1} but no such method, so invoking on converted type ({2})
060019=Attempt to create TypeConverterExpression for mapping of type {0}
060020=Invocation of method "{0}" on {1} is not supported.
                    
#
# Value Generators
#
061000=Couldnt create the sequence {0}
061001=Couldnt obtain a new sequence (unique id) : {0}
